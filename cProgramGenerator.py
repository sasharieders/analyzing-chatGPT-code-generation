#This class is used for all of the problems relating to the Deepfix dataset.

import time
import openai 
import os
import shutil
import subprocess
import sqlite3 

class CProgramGenerator:
    def __init__(self, apiKey, prompt):
        self.apiKey = apiKey
        self.prompt = prompt
        self.messages = [{"role": "system", "content": self.prompt}]
        self.index = 1

    #generateCPrograms will write multiple files that are C programs generated by chatGPT, given a prompt (e.g. "Please write this code"), and a folder called problemStatements that contain the corresponding problem statements.   
    def generateCPrograms(apiKey, prompt, problemStatements):
        messages = [{"role": "system", "content": prompt}]
        index = 1

        for row in enumerate(problemStatements):
            content = row[1]
            messages.append({"role": "user", "content": content})

            openai.api_key = apiKey
            completion = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages
            )

            createdCode = completion.choices[0].message['content']
            startInd = createdCode.find('#include')
            stopInd = createdCode.rfind('```')

            if startInd != -1 and stopInd != -1:
                createdCode = createdCode[startInd:stopInd]

            with open(f"createdCode{index}.c", "w") as file:
                file.write(createdCode)

            messages = [
                {"role": "system", "content": prompt}
            ]
            time.sleep(15)
            index += 1

    #This will take the C programs just written and move them to a new folder called subfolderName within your path given by folderPath
    def moveCreatedCodeToSubfolder(self, folderPath, subfolderName):
        subfolderPath = os.path.join(folderPath, subfolderName)
        os.makedirs(subfolderPath, exist_ok=True)
        for fileName in os.listdir(folderPath):
            if fileName.startswith('createdCode'):
                filePath = os.path.join(folderPath, fileName)
                newFilePath = os.path.join(subfolderPath, fileName)
                shutil.move(filePath, newFilePath)

    #This will test all the programs in a folder path, assuming they are written in C, and return the total number of programs it attempted to run along with the number of succesful programs 
    def testGeneratedCode(self, folderPath):
        numSuccessPrograms = 0
        totalNumProgs = 1
        for filename in os.listdir(folderPath):
            filePath = os.path.join(folderPath, filename)
            process = subprocess.run(["gcc", filePath], input='', capture_output=True)

            if process.returncode == 0:
                output = process.stdout.strip()
                numSuccessPrograms += 1
            totalNumProgs+=1
        return totalNumProgs,numSuccessPrograms
    
    #This is a function to get the broken programs from the deepfix dataset 
    def getBrokenPrograms():
        connection = sqlite3.connect('deepfix.db')
        cursor = connection.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        cursor.execute("SELECT * FROM Code")
        data = cursor.fetchall()
        cursor.close()
        connection.close()
        cProgs = []
        for row in data:
            cProgs.append(row[3])

        return cProgs
    
    #This is a function to fix the broken code given that you provide it with your chatGPT api key and an array of broken programs
    def fixPrograms(apiKey, brokenPrograms):
        messages = [{"role": "system", "content": "Please fix this C Code"}]
        index = 1

        for row in enumerate(brokenPrograms):
            content = row[1]
            messages.append({"role": "user", "content": content})

            openai.api_key = apiKey
            completion = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages
            )

            createdCode = completion.choices[0].message['content']
            startInd = createdCode.find('#include')
            stopInd = createdCode.rfind('```')

            if startInd != -1 and stopInd != -1:
                createdCode = createdCode[startInd:stopInd]

            with open(f"createdCode{index}.c", "w") as file:
                file.write(createdCode)

            messages = [
                {"role": "system", "content": "Please fix this C Code"}
            ]
            time.sleep(15)
            index += 1
        return createdCode
    
    #This cleans up the output of the files written by chatGPT since it saves in an odd format 
    def cleanCode(folderPath):
        for filename in os.listdir(folderPath):
            filePath = os.path.join(folderPath, filename)
            if os.path.isfile(filePath):
                with open(filePath, 'r') as file:
                    first_line = file.readline()
                    if not first_line.startswith("#include"):
                        os.remove(filePath)
    
    #This gets the error messages produced by the programs that do not succesfully run 
    def getErrorMessages(folderPath):
        errorMessages = {}
        for filename in os.listdir(folderPath):
            filePath = os.path.join(folderPath, filename)
            process = subprocess.run(["gcc", filePath], input='', capture_output=True, text=True)
            if process.returncode == 0:
                errorMessages[filename] = "none"
            else:
                errorMessages[filename] = "Program stderr:\n" + process.stderr
        return errorMessages
